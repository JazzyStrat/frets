let LAST_FRET = 15
let strings = []

let currentTriadDivs = []

let signage = '#'
let root

let quality
let inversion

let triadInfo = document.getElementById('triad-info')

// cgnst formations = ['root', '1st inv', '2nd inv']
// let currentInv = -1
// let currentRoot

let init = false
const dash = document.getElementById('dash')

let chordStat = document.createElement('h3')
dash.prepend(chordStat)

function calcTriadType() {
    const firstInt = currentTriadDivs[1].abs - currentTriadDivs[0].abs
    const secInt = currentTriadDivs[2].abs - currentTriadDivs[1].abs
    const intConfig = `${firstInt},${secInt}`
    currentTriadDivs.forEach((d) => {
        d.lastElementChild.classList.remove('third-color')
        d.lastElementChild.classList.remove('fifth-color')
    })

    switch (intConfig) {
        case '4,3':
            quality = 'maj'
            inversion = 'root position'
            currentTriadDivs[1].lastElementChild.classList.toggle('third-color')
            currentTriadDivs[2].lastElementChild.classList.toggle('fifth-color')
            break
        case '3,5':
            quality = 'maj'
            inversion = '1st inversion'
            currentTriadDivs[0].lastElementChild.classList.toggle('third-color')
            currentTriadDivs[1].lastElementChild.classList.toggle('fifth-color')
            break
        case '5,4':
            quality = 'maj'
            inversion = '2nd inversion'
            currentTriadDivs[2].lastElementChild.classList.toggle('third-color')
            currentTriadDivs[0].lastElementChild.classList.toggle('fifth-color')
            break
        case '3,4':
            quality = 'min'
            inversion = 'root position'
            break
        case '4,5':
            quality = 'min'
            inversion = '1st inversion'
            break
        case '5,3':
            quality = 'min'
            inversion = '2nd inversion'
            break
        case '3,3':
            quality = 'dim'
            inversion = 'root position'
            break
        case '3,6':
            quality = 'dim'
            inversion = 'root position'
            break
        case '6,3':
            quality = 'dim'
            inversion = 'root position'
            break
        case '4,4':
            quality = 'aug'
            inversion = 'magic3rd'
            break
        default:
            quality = 'other'
            inversion = 'other'
    }

    triadInfo.innerHTML = `<b>${root} ${quality}</b> <i>${inversion}`
}

const noteMap = new Map([
    ['A', 5], // #
    ['A#', 6],
    ['Bb', 6],
    ['B', 7], // #
    ['C', 8],
    ['C#', 9],
    ['Db', 9],
    ['D', 10], //
    ['D#', 11],
    ['Eb', 11],
    ['E', 0], // #
    ['F', 1], // b
    ['F#', 2],
    ['Gb', 2],
    ['G', 3], // #
    ['G#', 4],
    ['Ab', 4],
])

// Equal temperament â€” normalized distance from nutZero to fret n:
function TwelfthRoot(n) {
    return 1 - Math.pow(2, -n / 12)
}

// return note letter
function absToNote(note) {
    const noteVal = note % 12 // knock down to map val
    if (signage === '#') {
        for (let [k, v] of noteMap.entries()) {
            if (v == noteVal) {
                return k
            }
        }
    }
}

function buildFretboard() {
    const board = document.getElementById('board')

    // calc fret widths
    const fretWidths = []
    const visible = TwelfthRoot(LAST_FRET)
    let prev = 0
    for (let n = 1; n <= LAST_FRET; n++) {
        const d = TwelfthRoot(n)
        const segWidth = (d - prev) / visible // normalization
        fretWidths.push(segWidth)
        prev = d
    }

    let abs = 0 // discrete absolute pitches (0 == Open Lo E)
    let strDia = 5 // string thickness, shrinks
    for (let s = 0; s <= 5; s++) {
        // set string widths
        const row = document.createElement('div')
        row.className = 'string-row'

        row.style.setProperty('--before-height', `${strDia}px`)
        strDia *= 0.9 // shrink

        const string = []

        const nutZero = document.createElement('div')
        nutZero.className = 'nut'

        // Standard Tuning intervals - set nut values
        if (s <= 3) {
            abs = s * 5
        } else if (s == 4) {
            abs = abs + 4
        } else {
            abs = abs + 5
        }

        // bundle up baby, loosey goosey javascript
        nutZero.abs = abs
        nutZero.coord = [s, 0]
        string.push(nutZero)

        row.appendChild(nutZero)

        for (let [i, frac] of fretWidths.entries()) {
            const fw = document.createElement('div')
            fw.className = 'fw'
            fw.abs = abs + i + 1
            fw.coord = [s, i + 1]
            string.push(fw) // references

            fw.style.flex = `0 0 calc(${frac * 100}% )`

            const dot = document.createElement('div')
            dot.className = 'marker'

            // single dot markers
            if (i % 2 == 0 && i >= 2 && i <= 8 && s == 2) {
                fw.appendChild(dot)
            }
            // 12th fret double dot markers
            if (i == 11 && (s == 1 || s == 4)) {
                if (s == 1) {
                    dot.classList.add('marker-12-top')
                }
                if (s == 4) {
                    dot.classList.add('marker-12-bottom')
                }
                fw.appendChild(dot)
            }
            // final 15th fret marker
            if (i == 14 && s == 2) {
                fw.appendChild(dot)
            }

            row.appendChild(fw)
        }

        strings.push(string)
        board.appendChild(row)
    }

    const fretNums = document.createElement('div')
    fretNums.id = 'fret-nums'

    const nutZero = document.createElement('div')
    nutZero.className = 'nut'
    nutZero.innerHTML = `<p>0</p>`

    fretNums.appendChild(nutZero)
    // Align numbers under frets
    fretWidths.forEach((frac, i) => {
        const fretNum = document.createElement('div')
        fretNum.className = 'fret-number'
        fretNum.style.flex = `0 0 calc(${frac * 100}% )`
        fretNum.innerHTML = `<p>${i + 1}</p>`
        fretNums.appendChild(fretNum)
    })
    board.insertAdjacentElement('afterend', fretNums)

    // add hidden, togglable notes
    strings.forEach((string) => {
        string.forEach((note) => {
            const noteText = document.createElement('p')
            noteText.classList.add('emb')
            //
            let asLetter = absToNote(note.abs)
            noteText.innerText = asLetter
            note.appendChild(noteText)

            note.addEventListener('click', () => {
                note.classList.toggle('active')
                callMeBackBaby(note)
            })
        })
    })
}

// returns lowest possible triad pitches
function getTriadAbs(root, quality, spread) {
    // note =     let root = note
    // default to Maj Triad
    let third = root + 4
    let fifth = third + 3

    // mutate as needed from Maj default
    switch (quality) {
        case 'MIN':
            third -= 1
            break
        case 'DIM':
            third -= 1
            fifth -= 1
            break
        case 'AUG':
            fifth += 1
    }

    if (spread) {
        third += 12
    }
    // maybe instead of raw abs vals, get the lowest possible divs assoicated with those vals.
    // meaning choice between string string set or next

    return [root, third, fifth]
}

function invertUp(triad) {
    let lp = triad[0] // low pitch
    triad[0] = triad[1]
    triad[1] = triad[2]
    triad[2] = lp + 12
}

function invertDown(triad) {
    let hp = triad[2] // high pitch
    triad[2] = triad[1]
    triad[1] = triad[0]
    triad[0] = hp - 12
}

// sets prioritizing pos over inversion
function setTriadforReal(cd) {
    console.log(cd.coord, cd.abs) // E on A string: [1,7], 12

    currentTriadDivs.push(cd)

    let thirdDiv
    let fifthDiv
    const absMajThird = cd.abs + 4
    const absFifth = cd.abs + 7

    while (true) {
        // if two higher strings exist, attempt placing 0th maj triad
        if (cd.coord[0] + 2 < strings.length) {
            for (let f = 0; f < LAST_FRET; ++f) {
                if (strings[cd.coord[0] + 1][f].abs == absMajThird) {
                    thirdDiv = strings[cd.coord[0] + 1][f]
                    break
                }
            }
            for (let f = 0; f < LAST_FRET; ++f) {
                if (strings[cd.coord[0] + 2][f].abs == absFifth) {
                    fifthDiv = strings[cd.coord[0] + 2][f]
                    strings[cd.coord[0] + 2][f]

                    currentTriadDivs.push(thirdDiv)
                    currentTriadDivs.push(fifthDiv)
                    calcTriadType()
                    break
                }
            }

            currentTriadDivs.forEach((d) => {
                d.lastElementChild.classList.toggle('active')
            })
        }

        return
    }
}

function setTriad(triad, off, fretDelim) {
    let offset
    if (off === undefined) {
        offset = 0
    } else offset = off

    let upOctave = false
    let invert = false
    fretDelim = 9

    while (true) {
        let coords = []
        let notesSet = 0
        for (let i = 0; i < triad.length; i++) {
            let pair // [string, fret] coord
            for (let j = 0; j < fretDelim; j++) {
                if (strings[i + offset][j].abs == triad[i]) {
                    pair = [i + offset, j]
                    notesSet++
                }
            }
            coords.push(pair)
        }

        // wonderful
        if (notesSet == 3) {
            coords.forEach((pair) => {
                let div = strings[pair[0]][pair[1]]
                currentTriadDivs.push(div)
                div.lastElementChild.classList.toggle('active') // unhide
            })
            calcTriadType()
            return // get the hell outta here
        } else {
            // finding lowest possible + least inverted chord
            if (offset > 2 && !upOctave) {
                offset = 0
                upOctave = true
                triad.forEach((_, i) => {
                    triad[i] += 12
                })
                console.log(triad, 'octave++')
            } else if (offset > 2 && upOctave) {
                offset = 0
                invert = true
                triad.forEach((_, i) => {
                    triad[i] -= 12
                })
                invertUp(triad)
                console.log("i've been reborn, inverted!")
            } else {
                offset++
            }
        }
    }
}

function toggleSign() {
    let sharps
    if (strings[0][2].innerText.includes('#')) {
        sharps = true
    }
    if (sharps) {
        for (let i = 0; i < strings.length; i++) {
            for (let j = 0; j < strings[i].length; j++) {
                if (strings[i][j].innerText.length > 1) {
                    let letter = strings[i][j].innerText[0]
                    let ascii = letter.charCodeAt(0)
                    if (letter != 'G') {
                        letter = String.fromCharCode(ascii + 1)
                    } else {
                        letter = 'A'
                    }
                    strings[i][j].firstChild.innerText = letter + 'b'
                }
            }
        }
    } else {
        for (let i = 0; i < strings.length; i++) {
            for (let j = 0; j < strings[i].length; j++) {
                if (strings[i][j].innerText.length > 1) {
                    let letter = strings[i][j].innerText[0]
                    let ascii = letter.charCodeAt(0)
                    if (letter != 'A') {
                        letter = String.fromCharCode(ascii - 1)
                    } else {
                        letter = 'G'
                    }
                    strings[i][j].firstChild.innerText = letter + '#'
                }
            }
        }
    }
}

function invertTriadUp() {
    let rawAbs = []
    currentTriadDivs.forEach((div) => {
        rawAbs.push(div.abs)
        div.lastElementChild.classList.toggle('active') // unhide
    })

    invertUp(rawAbs)
    currentTriadDivs = []
    setTriad(rawAbs)
}

function invertTriadDown() {
    let rawAbs = []
    currentTriadDivs.forEach((div) => {
        rawAbs.push(div.abs)
        div.lastElementChild.classList.toggle('active') // unhide
    })

    invertDown(rawAbs)
    currentTriadDivs = []
    setTriad(rawAbs)
}

const signTog = document.getElementById('sign-toggle')
signTog.addEventListener('click', (e) => {
    if (e.target.innerText.includes('b')) {
        toggleSign()
        e.target.innerText = 'sharps (#)'
    } else {
        toggleSign()
        e.target.innerText = 'flats (b)'
    }
})

const upButton = document.getElementById('up')
upButton.addEventListener('click', () => {
    if (currentTriadDivs.length > 1) {
        invertTriadUp()
    } else {
        displayWarning()
    }
})
const downButton = document.getElementById('down')
downButton.addEventListener('click', () => {
    if (currentTriadDivs.length > 1) {
        invertTriadDown()
    } else {
        displayWarning()
    }
})

function displayWarning() {
    if (document.querySelector('.fade-out') == null) {
        const warning = document.createElement('p')
        warning.className = 'fade-out'
        warning.innerText = 'please select a note first'
        let lc = dash.lastElementChild
        dash.insertBefore(warning, lc)

        setTimeout(() => {
            warning.remove()
        }, 2000)
    }
}

// MAIN
buildFretboard()

function callMeBackBaby(clickedDiv) {
    root = clickedDiv.lastElementChild.innerText
    currentTriadDivs.forEach((div) => {
        div.lastElementChild.classList.toggle('active')
    })
    currentTriadDivs = []

    // let rt = getTriadAbs(clickedDiv.abs, 'MAJ')
    // setTriad(rt)
    setTriadforReal(clickedDiv)
}

document.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowUp' || event.key === 'k') {
        if (currentTriadDivs.length > 1) {
            invertTriadUp()
        }
        event.preventDefault()
    }
})

document.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowDown' || event.key === 'j') {
        if (currentTriadDivs.length > 1) {
            invertTriadDown()
        }
        event.preventDefault()
    }
})
